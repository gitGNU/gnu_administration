#!/usr/bin/python

# Cherry Backup
# Copyright (C) 2011  Sylvain Beucler
#
# Cherry Backup is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# Cherry Backup is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# Backup script to get the minimum set of files necessary to rebuild a
# system.  We also check if all files are well rsync'd, so we can
# track typos and renamed files.

# Do not backup generatable or sed-able files.  Document how to
# produce them instead.


# Input file (base.chb) format:
"""
root@mybox:/ -> mybox-backup/
  /etc/aliases
  /etc/mysql/my.cnf
  /etc/exim4/update-exim4.conf.conf
  /etc/munin/munin.conf

  /etc/apache2/sites-available/***

  --exclude /var/www/*/webalizer/*
  /var/www/site1/***
  /var/www/site2/***

  /etc/libnss-mysql.cfg
  /etc/libnss-mysql-root.cfg

[shell]
# Mangle passwords
sed -i -e 's/^password.*/password XXXXX/' \
  mybox-backup/etc/libnss-mysql.cfg \
  mybox-backup/etc/libnss-mysql-root.cfg
[/shell]
"""

import re
import os.path
import subprocess
import glob

filename_in = 'base.chb'
fin = open(filename_in)
fout = open('dl.sh', 'w')
cur_dir = None
mode_shell_input = False
mode_files = False
print_separation_line = False
already_seen_paths = {}
files = {}

fout.write("#!/bin/bash\n\n")
fout.write("# Generated by Cherry Backup - do not modify directly, edit '%s' instead\n" % filename_in)

while True:
    # "Parse" line-by-line
    line = fin.readline()
    if not line:
        break

    # Shell throughput mode
    if mode_shell_input:
        if line.startswith('[/shell]'):
            mode_shell_input = False
        else:
            fout.write(line)
    # Config mode
    else:
        # comments
        if line.strip().startswith('#'):
            pass
        elif line.strip() == '':
            print_separation_line = True
        # section
        elif not line.startswith(' ') and not line.startswith('\t'):
            # shell subsection
            if line.startswith('[shell]'):
                fout.write("  \\\n  --exclude '*'\n")
                mode_shell_input = True
                mode_files = False
            # host section
            else:
                match = re.match(r'^([^ ]+) -> ([^ ]+)\n', line)
                if match:
                    src = match.groups()[0]
                    cur_dir = match.groups()[1]
                    if not cur_dir.endswith('/'):
                        cur_dir += '/'
                    if mode_files:
                        fout.write("  \\\n  --exclude '*'\n")
                        mode_files = False
                    fout.write("\n")
                    fout.write("\n")
                    fout.write("echo '* %s -> %s'\n" % (src, cur_dir))
                    fout.write("rsync -zavHS --delete-excluded %s %s \\\n" % (src, cur_dir))
                    fout.write("  \\\n")
                    fout.write("  --exclude '*~' \\\n")
                    already_seen_paths = {}
                    files[cur_dir] = []
                    print_separation_line = True
        # Files: include or rsync option, with leading space
        else:
            mode_files = True
            if print_separation_line:
                    fout.write("  \\\n")
                    print_separation_line = False
            line = line.strip()
            # rsync option
            if line.startswith('-'):
                fout.write("  " + line + " \\\n")
            # include
            else:
                fullpath_elts = line.split('/')  # /usr/src/a -> ['', 'usr', 'src', 'a']
                i = 0
                # Write each path directory
                nb = len(fullpath_elts)
                if fullpath_elts[-1] == '***':
                    nb -= 1
                for i in range(2, nb):
                    cur_path = '/'.join(fullpath_elts[0:i])
                    if (i < len(fullpath_elts)):
                        cur_path += '/'
                    if not already_seen_paths.has_key(cur_path):
                        already_seen_paths[cur_path] = True
                        fout.write("  --include '%s' \\\n" % cur_path.replace("'", "'\\''"))
                fout.write("  --include '%s' \\\n" % line.replace("'", "'\\''"))
                files[cur_dir].append(line)
if mode_files:
    fout.write("  \\\n  --exclude '*'\n")
    mode_files = False
fout.close()


# Run the generated script
subprocess.call(['bash', 'dl.sh'])


# Check if specified files were truly rsync'd
print ""
for host in files:
    for bakpath in files[host]:
        bakpath = re.sub('^/*', '', bakpath)
        # There's a wildcard:
        if bakpath.find('*') != -1 or bakpath.find('?') != -1:
            bakdir = re.sub('\**$', '', bakpath)
            if bakpath.endswith('*') and bakdir.endswith('/'):
                if not os.path.isdir(os.path.join(host,bakdir)):
                    print "ERROR: " + os.path.join(host,bakdir) + " is not a directory"
            elif not glob.glob(os.path.join(host,bakpath)):
                print "ERROR: " + os.path.join(host,bakpath) + " has no match"
            # TODO: we don't support several situations ('**'
            # notation; trailing '*' in addition to other wildcard
            # usage; ...?)
        # Bare file or (empty) directory:
        elif not os.path.exists(os.path.join(host,bakpath)):
            print "ERROR: " + os.path.join(host,bakpath) + " is missing"


# TODO: If target directory is a SVN/Git/Bzr repository, prepare it
# for commit (deleted files marked as deleted, new files marked as
# added, etc.).  Do not commit, but support being run several times
# (aka support files already marked for addition/suppression but
# non-committed, possibly with a simple 'git checkout' before the
# rsync).
